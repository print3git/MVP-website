const fs = require("fs");
const { randomBytes } = require("crypto");

const suffix = randomBytes(4).toString("hex");
const file = `tests/glbPipeline.${suffix}.test.js`;

const banner =
  "// AUTO-GENERATED by scripts/generate-glb-tests.js — do not edit by hand\n";
let content = banner;
content +=
  "const { ingestGlb, validateSchema, transformGlb, renderGlb, uploadGlb } = require('../src/glbPipeline.js');\n\n";

const repeat = 16; // number of times to repeat each test case

const clusters = [
  {
    name: "Ingestion",
    tests: [
      { desc: "Accept a well-formed .glb", func: "ingestGlb", type: "success" },
      { desc: "Reject non-glb by extension", func: "ingestGlb", type: "fail" },
      {
        desc: "Reject non-glb by header bytes",
        func: "ingestGlb",
        type: "fail",
      },
    ],
  },
  {
    name: "Schema Validation",
    tests: [
      {
        desc: "Required chunk types (JSON, BIN)",
        func: "validateSchema",
        type: "success",
      },
      { desc: "Missing JSON chunk", func: "validateSchema", type: "fail" },
      { desc: "Unexpected extra chunks", func: "validateSchema", type: "fail" },
    ],
  },
  {
    name: "Field-Level Checks",
    tests: [
      {
        desc: "scene.nodes array exists",
        func: "validateSchema",
        type: "success",
      },
      {
        desc: "mesh.primitives[].indices is number",
        func: "validateSchema",
        type: "fail",
      },
      {
        desc: "bufferView.byteLength matches actual",
        func: "validateSchema",
        type: "fail",
      },
    ],
  },
  {
    name: "Size & Limits",
    tests: [
      { desc: "Tiny glb (<1KB)", func: "ingestGlb", type: "success" },
      { desc: "Huge glb (>100 MB)", func: "ingestGlb", type: "fail" },
      { desc: "Exactly-on-limit", func: "ingestGlb", type: "success" },
    ],
  },
  {
    name: "Transformation",
    tests: [
      {
        desc: "Round-trip import→export preserves semantics",
        func: "transformGlb",
        type: "success",
      },
      {
        desc: "Metadata pass-through (name, extras)",
        func: "transformGlb",
        type: "success",
      },
    ],
  },
  {
    name: "Optimization",
    tests: [
      {
        desc: "Draco-compressed vs. uncompressed",
        func: "transformGlb",
        type: "success",
      },
      {
        desc: "Quantization artifacts tolerances",
        func: "transformGlb",
        type: "success",
      },
    ],
  },
  {
    name: "Compatibility",
    tests: [
      { desc: "Load in three.js", func: "renderGlb", type: "success" },
      { desc: "Load in babylon.js", func: "renderGlb", type: "success" },
      {
        desc: "Load in your custom loader",
        func: "renderGlb",
        type: "success",
      },
    ],
  },
  {
    name: "Rendering Smoke",
    tests: [
      {
        desc: "Basic color geometry visible",
        func: "renderGlb",
        type: "success",
      },
      {
        desc: "Missing material → default fallback",
        func: "renderGlb",
        type: "success",
      },
    ],
  },
  {
    name: "Error Cases",
    tests: [
      {
        desc: "Corrupted JSON chunk (invalid UTF-8)",
        func: "ingestGlb",
        type: "fail",
      },
      {
        desc: "Corrupted BIN chunk (truncated)",
        func: "ingestGlb",
        type: "fail",
      },
      {
        desc: "Invalid accessor componentType",
        func: "validateSchema",
        type: "fail",
      },
    ],
  },
  {
    name: "Streaming / Chunked Upload",
    tests: [
      { desc: "Partial upload resume", func: "uploadGlb", type: "success" },
      { desc: "Canceled midway", func: "uploadGlb", type: "fail" },
    ],
  },
  {
    name: "Performance",
    tests: [
      {
        desc: "Bulk-load 100 small glbs in <2 s",
        func: "ingestGlb",
        type: "success",
      },
      {
        desc: "Memory doesn\u2019t spike above 200 MB",
        func: "ingestGlb",
        type: "success",
      },
    ],
  },
  {
    name: "Metadata & Storage",
    tests: [
      {
        desc: "S3 upload with correct Content-Type",
        func: "uploadGlb",
        type: "success",
      },
      { desc: "Metadata JSON saved in DB", func: "uploadGlb", type: "success" },
    ],
  },
  {
    name: "Edge Cases",
    tests: [
      { desc: "glb with zero nodes", func: "validateSchema", type: "fail" },
      {
        desc: "glb with no meshes (only cameras)",
        func: "validateSchema",
        type: "fail",
      },
      { desc: "Multi-scene glb", func: "validateSchema", type: "success" },
    ],
  },
];

for (const cluster of clusters) {
  content += `describe('${cluster.name}', () => {\n`;
  for (const t of cluster.tests) {
    for (let i = 0; i < repeat; i++) {
      const testName = `${t.desc} case ${i + 1}`
        .replace(/\\/g, "\\\\")
        .replace(/'/g, "\\'");
      content += `  it('${testName}', async () => {\n`;
      content += `    const buffer = Buffer.from([]); // TODO: generate ${t.type === "success" ? "valid" : "invalid"}Buffer\n`;
      if (t.type === "success") {
        content += `    await expect(${t.func}(buffer)).resolves.toMatchObject({});\n`;
      } else {
        content += `    await expect(${t.func}(buffer)).rejects.toThrow();\n`;
      }
      content += `  });\n`;
    }
  }
  content += `});\n\n`;
}

fs.writeFileSync(file, content);
console.log(`Generated ${file}`);
